import { ValidContentDispositions, ValidACLs, fetchEff, generateUploadThingURL, parseResponseJson, RetryError, UploadThingError, signPayload, isObject, contentDisposition, getTypeFromFileName, objectKeys, InvalidRouteConfigError, fileSizeToBytes, bytesToFileSize, FetchContext, getFullApiUrl, verifySignature, parseRequestJson, fillInputRouteConfig, asArray, getStatusCodeFromError } from '@uploadthing/shared';
export { UploadThingError } from '@uploadthing/shared';
import * as S from '@effect/schema/Schema';
import * as Effect from 'effect/Effect';
import * as Duration from 'effect/Duration';
import * as Schedule from 'effect/Schedule';
import { createConsola, LogLevels } from 'consola/core';
import * as Logger from 'effect/Logger';
import * as EffectLogLevel from 'effect/LogLevel';
import { process, isDevelopment } from 'std-env';
import * as Context from 'effect/Context';
import * as Data from 'effect/Data';
import { isActionType, VALID_ACTION_TYPES, isUploadThingHook, VALID_UT_HOOKS, UTFiles } from '../internal/types.js';
export { UTFiles } from '../internal/types.js';
import { lookup } from '@uploadthing/mime-types';

var version = "6.13.3";

function defaultErrorFormatter(error) {
    return {
        message: error.message
    };
}
function formatError(error, router) {
    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return errorFormatter(error);
}

const ContentDispositionSchema = S.Literal(...ValidContentDispositions);
S.Literal(...ValidACLs);
/**
 * =============================================================================
 * ======================== File Type Hierarchy ===============================
 * =============================================================================
 */ /**
 * Properties from the web File object, this is what the client sends when initiating an upload
 */ class FileUploadData extends S.Class("FileUploadData")({
    name: S.String,
    size: S.Number,
    type: S.String
}) {
}
/**
 * `.middleware()` can add a customId to the incoming file data
 */ class FileUploadDataWithCustomId extends FileUploadData.extend("FileUploadDataWithCustomId")({
    customId: S.NullOr(S.String)
}) {
}
/**
 * When files are uploaded, we get back
 * - a key
 * - a direct URL for the file
 * - an app-specific URL for the file (useful for scoping eg. for optimization allowed origins)
 */ class UploadedFileData extends FileUploadDataWithCustomId.extend("UploadedFileData")({
    key: S.String,
    url: S.String,
    appUrl: S.String
}) {
}
/**
 * =============================================================================
 * ======================== Server Response Schemas ============================
 * =============================================================================
 */ class PresignedBase extends S.Class("PresignedBaseSchema")({
    key: S.String,
    fileName: S.String,
    fileType: S.String,
    fileUrl: S.String,
    appUrl: S.String,
    pollingJwt: S.String,
    pollingUrl: S.String,
    contentDisposition: ContentDispositionSchema,
    customId: S.NullOr(S.String)
}) {
}
class MPUResponse extends PresignedBase.extend("MPUResponseSchema")({
    urls: S.Array(S.String),
    uploadId: S.String,
    chunkSize: S.Number,
    chunkCount: S.Number
}) {
}
class PSPResponse extends PresignedBase.extend("PSPResponseSchema")({
    url: S.String,
    fields: S.Record(S.String, S.String)
}) {
}
const PresignedURLResponse = S.Array(S.Union(PSPResponse, MPUResponse));
class PollUploadResponse extends S.Class("PollUploadResponse")({
    status: S.String,
    fileData: S.optional(S.Struct({
        fileKey: S.NullOr(S.String),
        fileName: S.String,
        fileSize: S.Number,
        fileType: S.String,
        metadata: S.NullOr(S.String),
        customId: S.NullOr(S.String),
        callbackUrl: S.optional(S.String),
        callbackSlug: S.optional(S.String)
    }))
}) {
}
class FailureCallbackResponse extends S.Class("FailureCallbackResponse")({
    success: S.Boolean,
    message: S.optional(S.String)
}) {
}
class ServerCallbackPostResponse extends S.Class("ServerCallbackPostResponse")({
    status: S.String
}) {
}
/**
 * =============================================================================
 * ======================== Client Action Payloads ============================
 * =============================================================================
 */ class UploadActionPayload extends S.Class("UploadActionPayload")({
    files: S.Array(FileUploadData),
    input: S.Unknown
}) {
}
class FailureActionPayload extends S.Class("FailureActionPayload")({
    fileKey: S.String,
    uploadId: S.NullOr(S.String),
    storageProviderError: S.optional(S.String),
    fileName: S.String
}) {
}
class MultipartCompleteActionPayload extends S.Class("MultipartCompleteActionPayload")({
    fileKey: S.String,
    uploadId: S.String,
    etags: S.Array(S.Struct({
        tag: S.String,
        partNumber: S.Number
    }))
}) {
}

const isValidResponse = (response)=>{
    if (!response.ok) return false;
    if (response.status >= 400) return false;
    if (!response.headers.has("x-uploadthing-version")) return false;
    return true;
};
const conditionalDevServer = (presigned, apiKey)=>{
    return Effect.gen(function*() {
        const file = yield* fetchEff(generateUploadThingURL(`/v6/pollUpload/${presigned.key}`)).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(PollUploadResponse)), Effect.andThen((res)=>res.status === "done" && res.fileData ? Effect.succeed(res.fileData) : Effect.fail(new RetryError())), Effect.retry({
            while: (err)=>err instanceof RetryError,
            schedule: Schedule.exponential(10, 4).pipe(// 10ms, 40ms, 160ms, 640ms...
            Schedule.union(Schedule.spaced(1000)), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(Duration.minutes(1))))
        }), Effect.catchTag("RetryError", ()=>new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "File took too long to upload"
            })));
        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
        if (!callbackUrl.startsWith("http")) callbackUrl = "http://" + callbackUrl;
        yield* Effect.logInfo(`SIMULATING FILE UPLOAD WEBHOOK CALLBACK`, callbackUrl);
        const payload = JSON.stringify({
            status: "uploaded",
            metadata: JSON.parse(file.metadata ?? "{}"),
            file: new UploadedFileData({
                url: presigned.fileUrl,
                appUrl: presigned.appUrl,
                key: presigned.key,
                name: file.fileName,
                size: file.fileSize,
                customId: file.customId,
                type: file.fileType
            })
        });
        const signature = yield* Effect.tryPromise({
            try: ()=>signPayload(payload, apiKey),
            catch: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to sign payload",
                    cause: e
                })
        });
        const callbackResponse = yield* fetchEff(callbackUrl, {
            method: "POST",
            body: payload,
            headers: {
                "Content-Type": "application/json",
                "uploadthing-hook": "callback",
                "x-uploadthing-signature": signature
            }
        }).pipe(Effect.catchTag("FetchError", ()=>Effect.succeed(new Response(null, {
                status: 500
            }))));
        if (isValidResponse(callbackResponse)) {
            yield* Effect.logInfo("Successfully simulated callback for file", presigned.key);
        } else {
            yield* Effect.logError(`
Failed to simulate callback for file '${file.fileKey}'. Is your webhook configured correctly?
  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal
  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues
`.trim());
        }
        return file;
    });
};

const colorize = (str, level)=>{
    // TODO: Maybe check is shell supports colors
    switch(level){
        case "error":
        case "fatal":
            return `\x1b[41m\x1b[30m${str}\x1b[0m`;
        case "warn":
            return `\x1b[43m\x1b[30m${str}\x1b[0m`;
        case "info":
        case "log":
            return `\x1b[44m\x1b[30m${str}\x1b[0m`;
        case "debug":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "trace":
            return `\x1b[47m\x1b[30m${str}\x1b[0m`;
        case "success":
            return `\x1b[42m\x1b[30m${str}\x1b[0m`;
        default:
            return str;
    }
};
const icons = {
    fatal: "⨯",
    error: "⨯",
    warn: "⚠️",
    info: "ℹ",
    log: "ℹ",
    debug: "⚙",
    trace: "→",
    success: "✓"
};
function formatStack(stack) {
    const cwd = "cwd" in process && typeof process.cwd === "function" ? process.cwd() : "__UnknownCWD__";
    return "  " + stack.split("\n").splice(1).map((l)=>l.trim().replace("file://", "").replace(cwd + "/", "")).join("\n  ");
}
function formatArgs(args) {
    const fmtArgs = args.map((arg)=>{
        if (isObject(arg) && typeof arg.stack === "string") {
            return arg.message + "\n" + formatStack(arg.stack);
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return arg;
    });
    return fmtArgs.map((arg)=>{
        if (typeof arg === "string") {
            return arg;
        }
        return JSON.stringify(arg, null, 4);
    });
}
const logger = createConsola({
    reporters: [
        {
            log: (logObj)=>{
                const { type, tag, date, args } = logObj;
                const icon = icons[type];
                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);
                const lines = formatArgs(args).join(" ") // concat all arguments to one space-separated string (like console does)
                .split("\n") // split all the newlines (e.g. from logged JSON.stringified objects)
                .map((l)=>logPrefix + " " + l) // prepend the log prefix to each line
                .join("\n"); // join all the lines back together
                // eslint-disable-next-line no-console
                console.log(lines);
            }
        }
    ],
    defaults: {
        tag: "UPLOADTHING"
    }
});
const effectLoggerLevelToConsolaLevel = {
    All: "verbose",
    Fatal: "error",
    Error: "error",
    Info: "info",
    Debug: "debug",
    Trace: "trace",
    Warning: "warn",
    None: "silent"
};
const withMinimalLogLevel = (level = "info")=>{
    logger.level = LogLevels[level];
    return Logger.withMinimumLogLevel({
        silent: EffectLogLevel.None,
        error: EffectLogLevel.Error,
        warn: EffectLogLevel.Warning,
        info: EffectLogLevel.Info,
        debug: EffectLogLevel.Debug,
        trace: EffectLogLevel.Trace,
        verbose: EffectLogLevel.All
    }[level]);
};
const ConsolaLogger = Logger.replace(Logger.defaultLogger, Logger.make(({ logLevel, message })=>{
    // FIXME: Probably log other stuff than just message?
    logger[effectLoggerLevelToConsolaLevel[logLevel._tag]](message);
}));

const uploadMultipart = (file, presigned)=>Effect.gen(function*() {
        yield* Effect.logDebug(`Uploading file ${file.name} with ${presigned.urls.length} chunks of size ${presigned.chunkSize} bytes each`);
        const etags = yield* Effect.forEach(presigned.urls, (url, index)=>{
            const offset = presigned.chunkSize * index;
            const end = Math.min(offset + presigned.chunkSize, file.size);
            const chunk = file.slice(offset, end);
            return uploadPart({
                url,
                chunk: chunk,
                contentDisposition: presigned.contentDisposition,
                contentType: file.type,
                fileName: file.name,
                maxRetries: 10,
                key: presigned.key,
                uploadId: presigned.uploadId
            }).pipe(Effect.andThen((etag)=>({
                    tag: etag,
                    partNumber: index + 1
                })), Effect.catchTag("RetryError", (e)=>Effect.die(e)));
        }, {
            concurrency: "inherit"
        });
        yield* Effect.logDebug("File", file.name, "uploaded successfully.");
        yield* Effect.logDebug("Completing multipart upload...");
        yield* completeMultipartUpload(presigned, etags);
        yield* Effect.logDebug("Multipart upload complete.");
    });
/**
 * Used by server uploads where progress is not needed.
 * Uses normal fetch API.
 */ const uploadPart = (opts)=>fetchEff(opts.url, {
        method: "PUT",
        body: opts.chunk,
        headers: {
            "Content-Type": opts.contentType,
            "Content-Disposition": contentDisposition(opts.contentDisposition, opts.fileName)
        }
    }).pipe(Effect.andThen((res)=>res.ok && res.headers.get("Etag") ? Effect.succeed(res.headers.get("Etag")) : Effect.fail(new RetryError())), Effect.retry({
        while: (res)=>res instanceof RetryError,
        schedule: Schedule.exponential(Duration.millis(10), 4).pipe(// 10ms, 40ms, 160ms, 640ms...
        Schedule.andThenEither(Schedule.spaced(Duration.seconds(1))), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(Duration.minutes(1)))),
        times: opts.maxRetries
    }), Effect.tapErrorTag("RetryError", ()=>// Max retries exceeded, tell UT server that upload failed
        abortMultipartUpload({
            key: opts.key,
            uploadId: opts.uploadId
        }).pipe(Effect.andThen((res)=>{
            new UploadThingError({
                code: "UPLOAD_FAILED",
                message: `Failed to upload file ${opts.fileName} to S3`,
                cause: res
            });
        }))));
const completeMultipartUpload = (presigned, etags)=>fetchEff(generateUploadThingURL("/v6/completeMultipart"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId,
            etags
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(S.Struct({
        success: S.Boolean,
        message: S.optional(S.String)
    }))), Effect.withSpan("completeMultipartUpload", {
        attributes: {
            etags,
            presigned
        }
    }));
const abortMultipartUpload = (presigned)=>fetchEff(generateUploadThingURL("/v6/failureCallback"), {
        method: "POST",
        body: JSON.stringify({
            fileKey: presigned.key,
            uploadId: presigned.uploadId
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(FailureCallbackResponse)), Effect.withSpan("abortMultipartUpload", {
        attributes: {
            presigned
        }
    }));

function getParseFn(parser) {
    if (typeof parser.parse === "function") {
        return parser.parse;
    }
    throw new Error("Invalid parser");
}

const getApiKey = (apiKey)=>{
    if (apiKey) return apiKey;
    if (process.env.UPLOADTHING_SECRET) return process.env.UPLOADTHING_SECRET;
    return undefined;
};
const getApiKeyOrThrow = (apiKey)=>{
    const key = getApiKey(apiKey);
    if (!key?.startsWith("sk_")) {
        throw new UploadThingError({
            code: "MISSING_ENV",
            message: "Missing or invalid API key. API keys must start with `sk_`."
        });
    }
    return key;
};

class FileSizeMismatch extends Data.Error {
    constructor(type, max, actual){
        const reason = `You uploaded a ${type} file that was ${bytesToFileSize(actual)}, but the limit for that type is ${max}`;
        super({
            reason
        });
        this._tag = "FileSizeMismatch";
        this.name = "FileSizeMismatchError";
    }
}
class FileCountMismatch extends Data.Error {
    constructor(type, boundtype, bound, actual){
        const reason = `You uploaded ${actual} file(s) of type '${type}', but the ${boundtype} for that type is ${bound}`;
        super({
            reason
        });
        this._tag = "FileCountMismatch";
        this.name = "FileCountMismatchError";
    }
}
// Verify that the uploaded files doesn't violate the route config,
// e.g. uploading more videos than allowed, or a file that is larger than allowed.
// This is double-checked on infra side, but we want to fail early to avoid network latency.
const assertFilesMeetConfig = (files, routeConfig)=>Effect.gen(function*() {
        const counts = {};
        for (const file of files){
            const type = yield* getTypeFromFileName(file.name, objectKeys(routeConfig));
            counts[type] = (counts[type] ?? 0) + 1;
            const sizeLimit = routeConfig[type]?.maxFileSize;
            if (!sizeLimit) {
                return yield* new InvalidRouteConfigError(type, "maxFileSize");
            }
            const sizeLimitBytes = yield* fileSizeToBytes(sizeLimit);
            if (file.size > sizeLimitBytes) {
                return yield* new FileSizeMismatch(type, sizeLimit, file.size);
            }
        }
        for(const _key in counts){
            const key = _key;
            const config = routeConfig[key];
            if (!config) return yield* new InvalidRouteConfigError(key);
            const count = counts[key];
            const min = config.minFileCount;
            const max = config.maxFileCount;
            if (min > max) {
                return yield* new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Invalid config during file count - minFileCount > maxFileCount",
                    cause: `minFileCount must be less than maxFileCount for key ${key}. got: ${min} > ${max}`
                });
            }
            if (count < min) {
                return yield* new FileCountMismatch(key, "minimum", min, count);
            }
            if (count > max) {
                return yield* new FileCountMismatch(key, "maximum", max, count);
            }
        }
        return null;
    });
class RequestInput extends /** #__PURE__ */ Context.Tag("uploadthing/RequestInput")() {
}
const parseAndValidateRequest = (input, opts, adapter)=>Effect.gen(function*() {
        const req = yield* Effect.isEffect(input.req) ? input.req : Effect.succeed(input.req);
        // Get inputs from query and params
        const url = new URL(req.url);
        const headers = req.headers;
        const params = url.searchParams;
        const action = params.get("actionType");
        const slug = params.get("slug");
        const hook = headers.get("uploadthing-hook");
        const utFrontendPackage = headers.get("x-uploadthing-package") ?? "unknown";
        const clientVersion = headers.get("x-uploadthing-version");
        const apiKey = getApiKey(opts.config?.uploadthingSecret);
        if (clientVersion != null && clientVersion !== version) {
            yield* Effect.logError(`Client version mismatch. Server version: ${version}, Client version: ${clientVersion}`);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Client version mismatch",
                cause: `Server version: ${version}, Client version: ${clientVersion}`
            });
        }
        if (!slug) {
            yield* Effect.logError("No slug provided in params:", params);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "No slug provided in params"
            });
        }
        if (slug && typeof slug !== "string") {
            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "`slug` must be a string",
                cause: msg
            });
        }
        if (!apiKey) {
            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "MISSING_ENV",
                message: `No secret provided`,
                cause: msg
            });
        }
        if (!apiKey.startsWith("sk_")) {
            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "MISSING_ENV",
                message: "Invalid API key. API keys must start with 'sk_'.",
                cause: msg
            });
        }
        if (utFrontendPackage && typeof utFrontendPackage !== "string") {
            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "`x-uploadthing-package` must be a string. eg. '@uploadthing/react'",
                cause: msg
            });
        }
        const uploadable = opts.router[slug];
        if (!uploadable) {
            const msg = `No file route found for slug ${slug}`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "NOT_FOUND",
                message: msg
            });
        }
        if (action && !isActionType(action)) {
            const msg = `Expected ${VALID_ACTION_TYPES.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${action}"`;
            yield* Effect.logError("Invalid action type", msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid action type ${action}`,
                message: msg
            });
        }
        if (hook && !isUploadThingHook(hook)) {
            const msg = `Expected ${VALID_UT_HOOKS.map((x)=>`"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${hook}"`;
            yield* Effect.logError("Invalid uploadthing hook", msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                cause: `Invalid uploadthing hook ${hook}`,
                message: msg
            });
        }
        if (!action && !hook || action && hook) {
            const msg = `Exactly one of 'actionType' or 'uploadthing-hook' must be provided`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: msg
            });
        }
        yield* Effect.logDebug("✔︎ All request input is valid");
        // FIXME: This should probably provide the full context at once instead of
        // partially in the `runRequestHandlerAsync` and partially in here...
        // Ref: https://discord.com/channels/@me/1201977154577891369/1207441839972548669
        const contextValue = yield* FetchContext;
        contextValue.baseHeaders["x-uploadthing-api-key"] = apiKey;
        contextValue.baseHeaders["x-uploadthing-fe-package"] = utFrontendPackage;
        contextValue.baseHeaders["x-uploadthing-be-adapter"] = adapter;
        const { isDev = isDevelopment } = opts.config ?? {};
        if (isDev) yield* Effect.logInfo("UploadThing dev server is now running!");
        const base = {
            req,
            config: opts.config ?? {},
            middlewareArgs: input.middlewareArgs,
            isDev,
            apiKey,
            slug,
            uploadable,
            hook: null,
            action: null
        };
        return action ? {
            ...base,
            action: action
        } : {
            ...base,
            hook: hook
        };
    });

const resolveCallbackUrl = Effect.gen(function*() {
    const { config, req, isDev } = yield* RequestInput;
    let callbackUrl = new URL(req.url);
    if (config?.callbackUrl) {
        callbackUrl = yield* getFullApiUrl(config.callbackUrl);
    } else if (process.env.UPLOADTHING_URL) {
        callbackUrl = yield* getFullApiUrl(process.env.UPLOADTHING_URL);
    }
    if (isDev || !callbackUrl.host.includes("localhost")) {
        return callbackUrl;
    }
    // Production builds have to have a public URL so UT can send webhook
    // Parse the URL from the headers
    let parsedFromHeaders = req.headers.get("origin") ?? req.headers.get("referer") ?? req.headers.get("host") ?? req.headers.get("x-forwarded-host");
    if (parsedFromHeaders && !parsedFromHeaders.includes("http")) {
        parsedFromHeaders = (req.headers.get("x-forwarded-proto") ?? "https") + "://" + parsedFromHeaders;
    }
    if (!parsedFromHeaders || parsedFromHeaders.includes("localhost")) {
        // Didn't find a valid URL in the headers, log a warning and use the original url anyway
        Effect.logWarning("You are using a localhost callback url in production which is not supported.", "Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production");
        return callbackUrl;
    }
    return yield* getFullApiUrl(parsedFromHeaders);
});

/**
 * Allows adapters to be fully async/await instead of providing services and running Effect programs
 */ const runRequestHandlerAsync = (handler, args, config)=>handler(args).pipe(withMinimalLogLevel(config?.logLevel), Effect.provide(ConsolaLogger), Effect.provideService(FetchContext, {
        fetch: config?.fetch ?? globalThis.fetch,
        baseHeaders: {
            "x-uploadthing-version": version,
            // These are filled in later in `parseAndValidateRequest`
            "x-uploadthing-api-key": undefined,
            "x-uploadthing-be-adapter": undefined,
            "x-uploadthing-fe-package": undefined
        }
    }), asHandlerOutput, Effect.runPromise);
const asHandlerOutput = (effect)=>Effect.catchAll(effect, (error)=>Effect.succeed({
            success: false,
            error
        }));
const handleRequest = RequestInput.pipe(Effect.andThen(({ action, hook })=>{
    if (hook === "callback") return handleCallbackRequest;
    switch(action){
        case "upload":
            return handleUploadAction;
        case "multipart-complete":
            return handleMultipartCompleteAction;
        case "failure":
            return handleMultipartFailureAction;
    }
}), Effect.map((output)=>({
        success: true,
        ...output
    })));
const buildRequestHandler = (opts, adapter)=>(input)=>handleRequest.pipe(Effect.provideServiceEffect(RequestInput, parseAndValidateRequest(input, opts, adapter)), Effect.catchTags({
            InvalidJson: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                }),
            BadRequestError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: e.getMessage(),
                    cause: e,
                    data: e.json
                }),
            FetchError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: typeof e.error === "string" ? e.error : e.message,
                    cause: e,
                    data: e.error
                }),
            ParseError: (e)=>new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "An error occured while parsing input/output",
                    cause: e
                })
        }), Effect.tapError((e)=>Effect.logError(e.message)));
const handleCallbackRequest = Effect.gen(function*() {
    const { req, uploadable, apiKey } = yield* RequestInput;
    const verified = yield* Effect.tryPromise({
        try: async ()=>verifySignature(await req.clone().text(), req.headers.get("x-uploadthing-signature"), apiKey),
        catch: ()=>new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid signature"
            })
    });
    yield* Effect.logDebug("Signature verified:", verified);
    if (!verified) {
        yield* Effect.logError("Invalid signature");
        return yield* new UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid signature"
        });
    }
    const requestInput = yield* Effect.flatMap(parseRequestJson(req), S.decodeUnknown(S.Struct({
        status: S.String,
        file: UploadedFileData,
        metadata: S.Record(S.String, S.Unknown)
    })));
    yield* Effect.logDebug("Handling callback request with input:", requestInput);
    const serverData = yield* Effect.tryPromise({
        try: async ()=>uploadable.resolver({
                file: requestInput.file,
                metadata: requestInput.metadata
            }),
        catch: (error)=>new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadComplete",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("Failed to run onUploadComplete. You probably shouldn't be throwing errors here.", error)));
    const payload = {
        fileKey: requestInput.file.key,
        callbackData: serverData ?? null
    };
    yield* Effect.logDebug("'onUploadComplete' callback finished. Sending response to UploadThing:", payload);
    yield* fetchEff(generateUploadThingURL("/v6/serverCallback"), {
        method: "POST",
        body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(ServerCallbackPostResponse)));
    return {
        body: null
    };
});
const runRouteMiddleware = (opts)=>Effect.gen(function*() {
        const { uploadable, middlewareArgs } = yield* RequestInput;
        const { files, input } = opts;
        yield* Effect.logDebug("Running middleware");
        const metadata = yield* Effect.tryPromise({
            try: async ()=>uploadable._def.middleware({
                    ...middlewareArgs,
                    input,
                    files
                }),
            catch: (error)=>error instanceof UploadThingError ? error : new UploadThingError({
                    code: "INTERNAL_SERVER_ERROR",
                    message: "Failed to run middleware",
                    cause: error
                })
        }).pipe(Effect.tapError((error)=>Effect.logError("An error occured in your middleware function", error)));
        if (metadata[UTFiles] && metadata[UTFiles].length !== files.length) {
            const msg = `Expected files override to have the same length as original files, got ${metadata[UTFiles].length} but expected ${files.length}`;
            yield* Effect.logError(msg);
            return yield* new UploadThingError({
                code: "BAD_REQUEST",
                message: "Files override must have the same length as files",
                cause: msg
            });
        }
        // Attach customIds from middleware to the files
        const filesWithCustomIds = yield* Effect.forEach(files, (file, idx)=>Effect.gen(function*() {
                const theirs = metadata[UTFiles]?.[idx];
                if (theirs && theirs.size !== file.size) {
                    yield* Effect.logWarning("File size mismatch. Reverting to original size");
                }
                return {
                    name: theirs?.name ?? file.name,
                    size: file.size,
                    customId: theirs?.customId
                };
            }));
        return {
            metadata,
            filesWithCustomIds
        };
    });
const handleUploadAction = Effect.gen(function*() {
    const opts = yield* RequestInput;
    const { files, input } = yield* Effect.flatMap(parseRequestJson(opts.req), S.decodeUnknown(UploadActionPayload));
    yield* Effect.logDebug("Handling upload request with input:", {
        files,
        input
    });
    // validate the input
    yield* Effect.logDebug("Parsing user input");
    const inputParser = opts.uploadable._def.inputParser;
    const parsedInput = yield* Effect.tryPromise({
        try: async ()=>getParseFn(inputParser)(input),
        catch: (error)=>new UploadThingError({
                code: "BAD_REQUEST",
                message: "Invalid input",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("An error occured trying to parse input", error)));
    yield* Effect.logDebug("Input parsed successfully", parsedInput);
    const { metadata, filesWithCustomIds } = yield* runRouteMiddleware({
        input: parsedInput,
        files
    });
    yield* Effect.logDebug("Parsing route config", opts.uploadable._def.routerConfig);
    const parsedConfig = yield* fillInputRouteConfig(opts.uploadable._def.routerConfig).pipe(Effect.catchTag("InvalidRouteConfig", (err)=>new UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config",
            cause: err
        })));
    yield* Effect.logDebug("Route config parsed successfully", parsedConfig);
    yield* Effect.logDebug("Validating files meet the config requirements", files);
    yield* assertFilesMeetConfig(files, parsedConfig).pipe(Effect.mapError((e)=>new UploadThingError({
            code: "BAD_REQUEST",
            message: `Invalid config: ${e._tag}`,
            cause: "reason" in e ? e.reason : e.message
        })));
    const callbackUrl = yield* resolveCallbackUrl.pipe(Effect.tapError((error)=>Effect.logError("Failed to resolve callback URL", error)), Effect.catchTag("InvalidURL", (err)=>new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: err.message
        })));
    yield* Effect.logDebug("Retrieving presigned URLs from UploadThing. Callback URL is:", callbackUrl.href);
    const presignedUrls = yield* fetchEff(generateUploadThingURL("/v6/prepareUpload"), {
        method: "POST",
        body: JSON.stringify({
            files: filesWithCustomIds,
            routeConfig: parsedConfig,
            metadata,
            callbackUrl: callbackUrl.origin + callbackUrl.pathname,
            callbackSlug: opts.slug
        }),
        headers: {
            "Content-Type": "application/json"
        }
    }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(PresignedURLResponse)));
    yield* Effect.logDebug("UploadThing responded with:", presignedUrls);
    yield* Effect.logDebug("Sending presigned URLs to client");
    let promise = undefined;
    if (opts.isDev) {
        const fetchContext = yield* FetchContext;
        promise = Effect.forEach(presignedUrls, (presigned)=>conditionalDevServer(presigned, opts.apiKey).pipe(Effect.either), {
            concurrency: 10
        }).pipe(Effect.provide(ConsolaLogger), Effect.provideService(FetchContext, fetchContext), Effect.runPromise);
    }
    return {
        body: presignedUrls,
        cleanup: promise
    };
});
const handleMultipartCompleteAction = Effect.gen(function*() {
    const opts = yield* RequestInput;
    const requestInput = yield* Effect.flatMap(parseRequestJson(opts.req), S.decodeUnknown(MultipartCompleteActionPayload));
    yield* Effect.logDebug("Handling multipart-complete request with input:", requestInput);
    yield* Effect.logDebug("Notifying UploadThing that multipart upload is complete");
    const completionResponse = yield* completeMultipartUpload({
        key: requestInput.fileKey,
        uploadId: requestInput.uploadId
    }, requestInput.etags);
    yield* Effect.logDebug("UploadThing responded with:", completionResponse);
    return {
        body: null
    };
});
const handleMultipartFailureAction = Effect.gen(function*() {
    const { req, uploadable } = yield* RequestInput;
    const { fileKey, uploadId } = yield* Effect.flatMap(parseRequestJson(req), S.decodeUnknown(FailureActionPayload));
    yield* Effect.logDebug("Handling failure request with input:", {
        fileKey,
        uploadId
    });
    yield* Effect.logDebug("Notifying UploadThing that upload failed");
    const failureResponse = yield* abortMultipartUpload({
        key: fileKey,
        uploadId
    });
    yield* Effect.logDebug("UploadThing responded with:", failureResponse);
    yield* Effect.logDebug("Running 'onUploadError' callback");
    yield* Effect.try({
        try: ()=>{
            uploadable._def.onUploadError({
                error: new UploadThingError({
                    code: "UPLOAD_FAILED",
                    message: `Upload failed for ${fileKey}`
                }),
                fileKey
            });
        },
        catch: (error)=>new UploadThingError({
                code: "INTERNAL_SERVER_ERROR",
                message: "Failed to run onUploadError",
                cause: error
            })
    }).pipe(Effect.tapError((error)=>Effect.logError("Failed to run onUploadError. You probably shouldn't be throwing errors here.", error)));
    return {
        body: null
    };
});
const buildPermissionsInfoHandler = (opts)=>{
    return ()=>{
        const permissions = objectKeys(opts.router).map((slug)=>{
            const route = opts.router[slug];
            const config = Effect.runSync(fillInputRouteConfig(route._def.routerConfig));
            return {
                slug,
                config
            };
        });
        return permissions;
    };
};

function incompatibleNodeGuard() {
    if (typeof process === "undefined") return;
    let major;
    let minor;
    const maybeNodeVersion = process.versions?.node?.split(".");
    if (maybeNodeVersion) {
        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));
    }
    const maybeNodePath = process.env?.NODE;
    if (!major && maybeNodePath) {
        const nodeVersion = /v(\d+)\.(\d+)\.(\d+)/.exec(maybeNodePath)?.[0];
        if (nodeVersion) {
            [major, minor] = nodeVersion.substring(1).split(".").map((v)=>parseInt(v, 10));
        }
    }
    if (!major || !minor) return;
    // Require ^18.13.0
    if (major > 18) return;
    if (major === 18 && minor >= 13) return;
    Effect.runSync(Effect.logError(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`));
    // Kill the process if it isn't going to work correctly anyway
    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
    process.exit?.(1);
}

function internalCreateBuilder(initDef = {}) {
    const _def = {
        // Default router config
        routerConfig: {
            image: {
                maxFileSize: "4MB"
            }
        },
        inputParser: {
            parse: ()=>undefined,
            _input: undefined,
            _output: undefined
        },
        middleware: ()=>({}),
        onUploadError: ()=>({}),
        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
        // Overload with properties passed in
        ...initDef
    };
    return {
        input (userParser) {
            return internalCreateBuilder({
                ..._def,
                inputParser: userParser
            });
        },
        middleware (userMiddleware) {
            return internalCreateBuilder({
                ..._def,
                middleware: userMiddleware
            });
        },
        onUploadComplete (userUploadComplete) {
            return {
                _def,
                resolver: userUploadComplete
            };
        },
        onUploadError (userOnUploadError) {
            return internalCreateBuilder({
                ..._def,
                onUploadError: userOnUploadError
            });
        }
    };
}
function createBuilder(opts) {
    return (input)=>{
        return internalCreateBuilder({
            routerConfig: input,
            ...opts
        });
    };
}

/**
 * Extension of the Blob class that simplifies setting the `name` and `customId` properties,
 * similar to the built-in File class from Node > 20.
 */ class UTFile extends Blob {
    constructor(parts, name, options){
        const optionsWithDefaults = {
            ...options,
            type: options?.type ?? (lookup(name) || "application/octet-stream"),
            lastModified: options?.lastModified ?? Date.now()
        };
        super(parts, optionsWithDefaults);
        this.name = name;
        this.customId = optionsWithDefaults.customId;
        this.lastModified = optionsWithDefaults.lastModified;
    }
}

const uploadPresignedPost = (file, presigned)=>Effect.gen(function*() {
        yield* Effect.logDebug(`Uploading file ${file.name} using presigned POST URL`);
        const formData = new FormData();
        Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));
        formData.append("file", file); // File data **MUST GO LAST**
        const res = yield* fetchEff(presigned.url, {
            method: "POST",
            body: formData,
            headers: new Headers({
                Accept: "application/xml"
            })
        }).pipe(Effect.tapErrorCause(()=>fetchEff(generateUploadThingURL("/v6/failureCallback"), {
                method: "POST",
                body: JSON.stringify({
                    fileKey: presigned.key,
                    uploadId: null
                }),
                headers: {
                    "Content-Type": "application/json"
                }
            }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(FailureCallbackResponse)))));
        if (!res.ok) {
            const text = yield* Effect.promise(res.text);
            yield* Effect.logError(`Failed to upload file ${file.name} to presigned POST URL. Response: ${text}`);
            return yield* new UploadThingError({
                code: "UPLOAD_FAILED",
                message: "Failed to upload file",
                cause: text
            });
        }
        yield* Effect.logDebug("File", file.name, "uploaded successfully");
    });

function guardServerOnly() {
    if (typeof window !== "undefined") {
        throw new UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "The `utapi` can only be used on the server."
        });
    }
}
const uploadFilesInternal = (input)=>getPresignedUrls(input).pipe(Effect.andThen((presigneds)=>Effect.forEach(presigneds, (file)=>uploadFile(file).pipe(Effect.tapError((error)=>Effect.logError("Upload failed:", error)), Effect.match({
                onFailure: (error)=>({
                        data: null,
                        error: UploadThingError.toObject(error instanceof UploadThingError ? error : new UploadThingError({
                            message: "Failed to upload file.",
                            code: "BAD_REQUEST",
                            cause: error
                        }))
                    }),
                onSuccess: (data)=>({
                        data,
                        error: null
                    })
            })), {
            concurrency: 10
        })));
/**
 * FIXME: downloading everything into memory and then upload
 * isn't the best. We should support streams so we can download
 * just as much as we need at any time.
 */ const downloadFiles = (urls, downloadErrors)=>Effect.forEach(urls, (_url, idx)=>Effect.gen(function*() {
            let url = isObject(_url) ? _url.url : _url;
            if (typeof url === "string") {
                // since dataurls will result in name being too long, tell the user
                // to use uploadFiles instead.
                if (url.startsWith("data:")) {
                    downloadErrors[idx] = UploadThingError.toObject(new UploadThingError({
                        code: "BAD_REQUEST",
                        message: "Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only."
                    }));
                    return null;
                }
            }
            url = new URL(url);
            const { name = url.pathname.split("/").pop() ?? "unknown-filename", customId = undefined } = isObject(_url) ? _url : {};
            const response = yield* fetchEff(url);
            if (!response.ok) {
                downloadErrors[idx] = UploadThingError.toObject(new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "Failed to download requested file.",
                    cause: response
                }));
                return undefined;
            }
            return yield* Effect.promise(()=>response.blob()).pipe(Effect.andThen((blob)=>new UTFile([
                    blob
                ], name, {
                    customId
                })));
        }), {
        concurrency: 10
    });
const getPresignedUrls = (input)=>Effect.gen(function*() {
        const { files, metadata, contentDisposition, acl } = input;
        const fileData = files.map((file)=>({
                name: file.name ?? "unnamed-blob",
                type: file.type,
                size: file.size,
                ..."customId" in file ? {
                    customId: file.customId
                } : {}
            }));
        yield* Effect.logDebug("Getting presigned URLs for files", fileData);
        const responseSchema = S.Struct({
            data: PresignedURLResponse
        });
        const presigneds = yield* fetchEff(generateUploadThingURL("/v6/uploadFiles"), {
            method: "POST",
            cache: "no-store",
            body: JSON.stringify({
                files: fileData,
                metadata,
                contentDisposition,
                acl
            }),
            headers: {
                "Content-Type": "application/json"
            }
        }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(responseSchema)), Effect.catchTag("ParseError", (e)=>Effect.die(e)), Effect.catchTag("FetchError", (e)=>Effect.die(e)));
        yield* Effect.logDebug("Got presigned URLs:", presigneds.data);
        return files.map((file, i)=>({
                file,
                presigned: presigneds.data[i]
            }));
    });
const uploadFile = (input)=>Effect.gen(function*() {
        const { file, presigned } = input;
        if ("urls" in presigned) {
            yield* uploadMultipart(file, presigned);
        } else {
            yield* uploadPresignedPost(file, presigned);
        }
        yield* fetchEff(generateUploadThingURL(`/v6/pollUpload/${presigned.key}`)).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(PollUploadResponse)), Effect.tap(Effect.logDebug("Polled upload", presigned.key)), Effect.andThen((res)=>res.status === "done" ? Effect.succeed(undefined) : Effect.fail(new RetryError())), Effect.retry({
            while: (err)=>err instanceof RetryError,
            schedule: Schedule.exponential(Duration.millis(10), 4).pipe(// 10ms, 40ms, 160ms, 640ms...
            Schedule.andThenEither(Schedule.spaced(Duration.seconds(1))), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(Duration.minutes(1))))
        }), Effect.catchTag("RetryError", (e)=>Effect.die(e)));
        return {
            key: presigned.key,
            url: presigned.fileUrl,
            appUrl: presigned.appUrl,
            name: file.name,
            size: file.size,
            type: file.type,
            customId: "customId" in file ? file.customId ?? null : null
        };
    });
function parseTimeToSeconds(time) {
    const match = time.toString().split(/(\d+)/).filter(Boolean);
    const num = Number(match[0]);
    const unit = (match[1] ?? "s").trim().slice(0, 1);
    const multiplier = {
        s: 1,
        m: 60,
        h: 3600,
        d: 86400
    }[unit];
    return num * multiplier;
}

class UTApi {
    constructor(opts){
        this.requestUploadThing = (pathname, body, responseSchema)=>{
            const url = generateUploadThingURL(pathname);
            Effect.runSync(Effect.logDebug("Requesting UploadThing:", {
                url,
                body,
                headers: this.defaultHeaders
            }));
            const headers = new Headers([
                [
                    "Content-Type",
                    "application/json"
                ]
            ]);
            for (const [key, value] of Object.entries(this.defaultHeaders)){
                if (typeof value === "string") headers.set(key, value);
            }
            return fetchEff(url, {
                method: "POST",
                cache: "no-store",
                body: JSON.stringify(body),
                headers
            }).pipe(Effect.andThen(parseResponseJson), Effect.andThen(S.decodeUnknown(responseSchema)), Effect.catchTag("FetchError", (err)=>Effect.logError("Request failed:", err).pipe(Effect.andThen(()=>Effect.die(err)))), Effect.catchTag("ParseError", (err)=>Effect.logError("Response parsing failed:", err).pipe(Effect.andThen(()=>Effect.die(err)))), Effect.tap((res)=>Effect.logDebug("UploadThing response:", res)));
        };
        this.executeAsync = (program, signal)=>program.pipe(withMinimalLogLevel(this.logLevel), Effect.provide(ConsolaLogger), Effect.provideService(FetchContext, {
                fetch: this.fetch,
                baseHeaders: this.defaultHeaders
            }), (e)=>Effect.runPromise(e, signal ? {
                    signal
                } : undefined));
        /**
   * Request to delete files from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * await deleteFiles("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   *
   * @example
   * await deleteFiles(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   *
   * @example
   * await deleteFiles("myCustomIdentifier", { keyType: "customId" })
   */ this.deleteFiles = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class DeleteFileResponse extends S.Class("DeleteFileResponse")({
                success: S.Boolean,
                deletedCount: S.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/deleteFiles", keyType === "fileKey" ? {
                fileKeys: asArray(keys)
            } : {
                customIds: asArray(keys)
            }, DeleteFileResponse));
        };
        /**
   * Request file URLs from UploadThing storage.
   * @param {string | string[]} fileKeys
   *
   * @example
   * const data = await getFileUrls("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg");
   * console.log(data); // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg"}]
   *
   * @example
   * const data = await getFileUrls(["2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg","1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"])
   * console.log(data) // [{key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", url: "https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg" },{key: "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg", url: "https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg"}]
   */ this.getFileUrls = async (keys, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            class GetFileUrlResponse extends S.Class("GetFileUrlResponse")({
                data: S.Array(S.Struct({
                    key: S.String,
                    url: S.String
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getFileUrl", keyType === "fileKey" ? {
                fileKeys: keys
            } : {
                customIds: keys
            }, GetFileUrlResponse));
        };
        /**
   * Request file list from UploadThing storage.
   * @param {object} opts
   * @param {number} opts.limit The maximum number of files to return
   * @param {number} opts.offset The number of files to skip
   *
   * @example
   * const data = await listFiles({ limit: 1 });
   * console.log(data); // { key: "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", id: "2e0fdb64-9957-4262-8e45-f372ba903ac8" }
   */ this.listFiles = async (opts)=>{
            guardServerOnly();
            class ListFileResponse extends S.Class("ListFileResponse")({
                hasMore: S.Boolean,
                files: S.Array(S.Struct({
                    id: S.String,
                    customId: S.NullOr(S.String),
                    key: S.String,
                    name: S.String,
                    status: S.Literal("Deletion Pending", "Failed", "Uploaded", "Uploading")
                }))
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/listFiles", {
                ...opts
            }, ListFileResponse));
        };
        this.renameFiles = async (updates)=>{
            guardServerOnly();
            class RenameFileResponse extends S.Class("RenameFileResponse")({
                success: S.Boolean
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/renameFiles", {
                updates: asArray(updates)
            }, RenameFileResponse));
        };
        /** @deprecated Use {@link renameFiles} instead. */ this.renameFile = this.renameFiles;
        this.getUsageInfo = async ()=>{
            guardServerOnly();
            class GetUsageInfoResponse extends S.Class("GetUsageInfoResponse")({
                totalBytes: S.Number,
                appTotalBytes: S.Number,
                filesUploaded: S.Number,
                limitBytes: S.Number
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/getUsageInfo", {}, GetUsageInfoResponse));
        };
        /** Request a presigned url for a private file(s) */ this.getSignedURL = async (key, opts)=>{
            guardServerOnly();
            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;
            const { keyType = this.defaultKeyType } = opts ?? {};
            if (opts?.expiresIn && isNaN(expiresIn)) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds."
                });
            }
            if (expiresIn && expiresIn > 86400 * 7) {
                throw new UploadThingError({
                    code: "BAD_REQUEST",
                    message: "expiresIn must be less than 7 days (604800 seconds)."
                });
            }
            class GetSignedUrlResponse extends S.Class("GetSignedUrlResponse")({
                url: S.String
            }) {
            }
            return await this.executeAsync(this.requestUploadThing("/v6/requestFileAccess", keyType === "fileKey" ? {
                fileKey: key,
                expiresIn
            } : {
                customId: key,
                expiresIn
            }, GetSignedUrlResponse));
        };
        /**
   * Update the ACL of a file or set of files.
   *
   * @example
   * // Make a single file public
   * await utapi.updateACL("2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg", "public-read");
   *
   * // Make multiple files private
   * await utapi.updateACL(
   *   [
   *     "2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg",
   *     "1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg",
   *   ],
   *   "private",
   * );
   */ this.updateACL = async (keys, acl, opts)=>{
            guardServerOnly();
            const { keyType = this.defaultKeyType } = opts ?? {};
            const updates = asArray(keys).map((key)=>{
                return keyType === "fileKey" ? {
                    fileKey: key,
                    acl
                } : {
                    customId: key,
                    acl
                };
            });
            const responseSchema = S.Struct({
                success: S.Boolean
            });
            return await this.executeAsync(this.requestUploadThing("/v6/updateACL", {
                updates
            }, responseSchema));
        };
        // Assert some stuff
        guardServerOnly();
        incompatibleNodeGuard();
        const apiKey = getApiKeyOrThrow(opts?.apiKey);
        this.fetch = opts?.fetch ?? globalThis.fetch;
        this.defaultHeaders = {
            "x-uploadthing-api-key": apiKey,
            "x-uploadthing-version": version,
            "x-uploadthing-be-adapter": "server-sdk",
            "x-uploadthing-fe-package": undefined
        };
        this.defaultKeyType = opts?.defaultKeyType ?? "fileKey";
        this.logLevel = opts?.logLevel;
    }
    async uploadFiles(files, opts) {
        guardServerOnly();
        const uploads = await this.executeAsync(Effect.flatMap(uploadFilesInternal({
            files: asArray(files),
            contentDisposition: opts?.contentDisposition ?? "inline",
            metadata: opts?.metadata ?? {},
            acl: opts?.acl
        }), (ups)=>Effect.succeed(Array.isArray(files) ? ups : ups[0])).pipe(Effect.tap((res)=>Effect.logDebug("Finished uploading:", res))), opts?.signal);
        return uploads;
    }
    async uploadFilesFromUrl(urls, opts) {
        guardServerOnly();
        const downloadErrors = {};
        const uploads = await this.executeAsync(downloadFiles(asArray(urls), downloadErrors).pipe(Effect.andThen((files)=>files.filter((f)=>f != null)), Effect.andThen((files)=>uploadFilesInternal({
                files,
                contentDisposition: opts?.contentDisposition ?? "inline",
                metadata: opts?.metadata ?? {},
                acl: opts?.acl
            }))), opts?.signal);
        /** Put it all back together, preserve the order of files */ const responses = asArray(urls).map((_, index)=>{
            if (downloadErrors[index]) {
                return {
                    data: null,
                    error: downloadErrors[index]
                };
            }
            return uploads.shift();
        });
        /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];
        Effect.runSync(Effect.logDebug("Finished uploading:", uploadFileResponse));
        return uploadFileResponse;
    }
}

const createUploadthing = (opts)=>createBuilder(opts);
/** @internal */ const INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter)=>{
    incompatibleNodeGuard();
    const requestHandler = buildRequestHandler(opts, adapter);
    const getBuildPerms = buildPermissionsInfoHandler(opts);
    const POST = async (request)=>{
        const req = request instanceof Request ? request : request.request;
        const response = await runRequestHandlerAsync(requestHandler, {
            req,
            middlewareArgs: {
                req,
                event: undefined,
                res: undefined
            }
        }, opts.config);
        if (response.success === false) {
            return Response.json(formatError(response.error, opts.router), {
                status: getStatusCodeFromError(response.error),
                headers: {
                    "x-uploadthing-version": version
                }
            });
        }
        const res = Response.json(response.body, {
            headers: {
                "x-uploadthing-version": version
            }
        });
        // @ts-expect-error - this is a custom property
        res.cleanup = response.cleanup;
        return res;
    };
    const GET = (request)=>{
        return Response.json(getBuildPerms(), {
            headers: {
                "x-uploadthing-version": version
            }
        });
    };
    return {
        GET,
        POST
    };
};
const createRouteHandler = (opts)=>INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, "server");
const extractRouterConfig = (router)=>buildPermissionsInfoHandler({
        router
    })();
/**
 * @deprecated Use {@link createRouteHandler} instead
 */ const createServerHandler = createRouteHandler;

export { INTERNAL_DO_NOT_USE_createRouteHandlerCore, UTApi, UTFile, createRouteHandler, createServerHandler, createUploadthing, extractRouterConfig };
